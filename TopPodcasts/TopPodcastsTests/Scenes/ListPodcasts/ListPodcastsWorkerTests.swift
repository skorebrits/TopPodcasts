//
//  ListPodcastsWorkerTests.swift
//  TopPodcasts
//
//  Created by Sander Korebrits on 17/08/2018.
//  Copyright (c) 2018 designlapp. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

@testable import TopPodcasts
import XCTest
import OHHTTPStubs

class ListPodcastsWorkerTests: XCTestCase{
  
    // MARK: Subject under test
    var sut: ListPodcastsWorker!
  
    // MARK: Test lifecycle
    override func setUp(){
        super.setUp()
        setupListPodcastsWorker()
    }

    override func tearDown(){
        super.tearDown()
        OHHTTPStubs.removeAllStubs()
    }

    // MARK: Test setup

    func setupListPodcastsWorker(){
        sut = ListPodcastsWorker()
    }

    // MARK: Test doubles

    // MARK: Tests
    func testListPodcastShouldReturnPodcasts(){
        /*
         https://rss.itunes.apple.com/api/v1/nl/podcasts/top-podcasts/all/25/explicit.json
         */
        let bundle = Bundle(for: type(of: self))
        stub(condition: isHost("rss.itunes.apple.com")) { (request) -> OHHTTPStubsResponse in
            return OHHTTPStubsResponse(fileURL: bundle.url(forResource: "TopPodcastsResponse", withExtension: "json")!, statusCode: 200, headers: nil)
        }
        
        let excepting = XCTestExpectation(description: "Should Return Podcasts")
        sut.listPodcasts { (success, podcasts, errorMessage) in
            XCTAssertEqual(success, true)
            XCTAssertNil(errorMessage, "error message should be nil")
            XCTAssertEqual(podcasts.count, 25)
            excepting.fulfill()
        }
        wait(for: [excepting], timeout: 5)
    }
    
    func testListPodcastsShouldError(){
        let excepting = XCTestExpectation(description: "Should Error on no Network")
        stub(condition: isHost("rss.itunes.apple.com")) { (request) -> OHHTTPStubsResponse in
            let notConnectedError = NSError(domain: NSURLErrorDomain, code: URLError.notConnectedToInternet.rawValue)
            return OHHTTPStubsResponse(error:notConnectedError)
        }
        sut.listPodcasts { (success, podcasts, errorMessage) in
            XCTAssertEqual(success, false)
            XCTAssertEqual(podcasts.count, 0)
            XCTAssertNotNil(errorMessage)
            excepting.fulfill()
        }
        wait(for: [excepting], timeout: 5)
    }
    
    func testFetchShouldReturnImage(){
        let excepting = XCTestExpectation(description: "Should fech image")
        let bundle = Bundle(for: type(of: self))
        stub(condition: isHost("is4-ssl.mzstatic.com")) { (request) -> OHHTTPStubsResponse in
            return OHHTTPStubsResponse(fileURL: bundle.url(forResource: "200x200bb", withExtension: "png")!, statusCode: 200, headers: nil)
        }
        sut.fetchImageArtwork(url: "https://is4-ssl.mzstatic.com/image/thumb/Music118/v4/2b/0c/15/2b0c15ea-3ac8-71ad-ffda-f8806de09a6c/source/200x200bb.png") { (success, image, errorMessage) in
            XCTAssertEqual(success, true)
            XCTAssertNil(errorMessage, "error message should be nil")
            XCTAssertEqual(image!.size, CGSize(width: 200, height: 200))
            excepting.fulfill()
        }
        wait(for: [excepting], timeout: 5)
    }
    
    func testFetchShouldError(){
        let excepting = XCTestExpectation(description: "Should Error on no Network")
        stub(condition: isHost("is4-ssl.mzstatic.com")) { (request) -> OHHTTPStubsResponse in
            let notConnectedError = NSError(domain: NSURLErrorDomain, code: URLError.notConnectedToInternet.rawValue)
            return OHHTTPStubsResponse(error:notConnectedError)
        }
        sut.fetchImageArtwork(url: "https://is4-ssl.mzstatic.com/image/thumb/Music118/v4/2b/0c/15/2b0c15ea-3ac8-71ad-ffda-f8806de09a6c/source/200x200bb.png") { (success, image, errorMessage) in
            XCTAssertEqual(success, false)
            XCTAssertNil(image)
            XCTAssertNotNil(errorMessage)
            excepting.fulfill()
        }
        wait(for: [excepting], timeout: 5)
    }
}
